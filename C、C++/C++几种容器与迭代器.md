## 容器

### vector

可变大小数组。支持快速随机访问。在尾部之外的位置插入新的元素可能会很慢。

一些操作：

v[n]		返回vector中第n个位置上元素的引用

v1 = v2		用v2中的元素拷贝替换v1中的元素

v1 = {a1, a2, a3, a4 ....}	用列表中的元素替换v1中的元素，替换后v1的大小和后面列表大小一样

v1 == v2		v1、v2相等当且仅当元素数目相同且对应位置元素一样





### deque

双端队列。支持快速随机访问。在头尾位置插入、删除速度会很快。在中间插入、删除元素的代价（可能）会很大。

### list

双向链表，只支持双向顺序访问。在任何位置插入、删除元素速度都会很快。

### forward_list

单向链表。只支持单向顺序访问。在任何位置插入、删除元素速度都会很快。

### array

固定大小数组。支持快速随机访问。不能添加或者删除元素。

### string

与vector相似的容器，但是专门用来保存字符。随机访问快，在尾部插入、删除速度快。



**注：**

1）string和vector将元素存在连续的存储空间，通过元素的下标计算元素的地址速度比较快。在中间插入新的元素需要移动后面的所有元素到新的空间，比较费时。

2）list与forward_list在任何位置插入和删除元素的速度都非常快。但不支持元素的快速访问，需要遍历整个容器才能访问某一个元素。内存开销也更大。

3）通常vector是最好的选择，除非有更好的理由选择其他容器。

4）如果需要很多小的元素，且空间额外开销很重要，不要使用list和forward_list.

5）如果只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则

——首先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，会很容易向vector末尾追就加数		  	 据，然后再调用标准库中的sort函数，避免在中间插入元素。

——如果必须在中间插入元素，考虑在输入阶段使用list，一旦输入完成，将list中内容拷贝到vector中。

## 迭代器

